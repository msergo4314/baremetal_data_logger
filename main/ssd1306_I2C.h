#ifndef ssd1306_I2C // header guard

#define ssd1306_I2C
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "rom/ets_sys.h"

#include "my_I2C.h" // custom I2C bit-banged protocol implementation

#define SSD1306_ADDRESS 0x3D // can be 0x3C or 0x3D depending on the D/C# pin

// these masks will be used to determine what contorl bytes will be for transmissions

#define SSD1306_CO_BIT (1 << 7)   // Continuation bit (bit 7)
#define SSD1306_DC_BIT (1 << 6)   // Data/Command bit (bit 6)

// macro to determine what the control byte looks like for any transmission
#define SSD1306_CONTROL_BYTE(co, dc) ((co ? SSD1306_CO_BIT : 0) | (dc ? SSD1306_DC_BIT : 0))

typedef struct pixel_coord {
    // the OLED measures 64x128 pixels so a byte is plenty of space for X and Y
    uint8_t x;
    uint8_t y;
} ssd1306_pixel_coordinate;

// the SSD1306 supports 3 addressing modes: Page, Horizontal, and Vertical
typedef enum {
    /*
    The Page address pointer is selected first, then the start column and end column. The columns increment on each read/write
    and if the column address pointer reaches the column end address it resets to column start WITHOUT updating the page pointer
    this means it will overwrite data instead of going to the next page
    */
    PAGE,

    /*
    Works identically to PAGE addressing but increments the page pointer when the column pointer reaches the column end
    this essentially means you can write subsequent lines 
    */
    HORIZONTAL, // same as PAGE but wraps around to the next page instead of the same page

    /*
    the page address pointer is incremented by 1 each read/write instead of the column. 
    Wraps to next column when all pages are set
    */
    VERTICAL
} ADDRESSING_MODE;

ADDRESSING_MODE current_mode;
/*

When transmitting bytes with I2C, we have two options for the OLED -- a command or data
commands tell the display to do something, such as changing contrast or turning all pixels ON/OFF
data tells us which bits to turn on and off using the paging system of the SSD1306


Contorl byte has the format C0, D/C, 0, 0, 0, 0, 0, 0 (6 trailing 0s) -- only the 2 MSBs matter

C0 determines if the following transmission will containg data bytes ONLY. If it is 0, this is the case

D/C determines if the next byte is data or a command 
--> 0 for commands, and 1 for data stored in the GDDRAM (note: the GDDRAM pointer will increase for every data write)

Each control or data byte will have an ACK bit

GDDRAM
a bit mapped static RAM which holds the bit pattern to be displayed. Thd size of the RAM is 128x64 bits (the size of the screen)
the RAM is didvided into 8 pages from PAGE0 to PAGE7

the coordinate (0, 0) is located at the top left of the screen (assuming no column/row remapping). this is page 0, column 0
Each page has a height of 8 pixels from top to bottom (8x8 = 64) and a width of 128 segments (indexed 0-127 from left to right assuming no remaps)

When one byte is written to GDDRAM, all rows of that page are refreshed for a column length of 8 bits.
Bit D0 (the LSB) is written at the top and D7 at the bottom

*/

void ssd1306_init() {
    I2C_init();
    current_mode = PAGE; // we will just stick with the page mode here
}

// wraps the I2C function for the ssd1306 display
bool ssd1306_write_bytes(const byte* stream_of_bytes, size_t number_of_bytes, bool start, bool stop) {
    return I2C_send_byte_stream(SSD1306_ADDRESS, stream_of_bytes, number_of_bytes, WRITE, start, stop);
}


// sets contrast of display. Higher byte value correlates to higher contrast
bool ssd1306_set_contrast(byte contrast) {
    // to set contrast we will transmit two bytes -- the command byte which indicates we want to change the contrast, and the value itself (data byte)
    // control byte first: Co=0, D/C=0 → command stream with no more control bytes
    byte transmission[3] = {SSD1306_CONTROL_BYTE(0, 0), 0x81, contrast};
    return ssd1306_write_bytes(transmission, sizeof(transmission), true, true);
}


bool ssd1306_entire_display_on(void) {
    // A5 is the command for entire display ON with no regard for RAM content

    // control byte first: Co=0, D/C=0 → command stream with no more control bytes
    byte transmission[2] = {SSD1306_CONTROL_BYTE(0, 0), 0xA5};
    return ssd1306_write_bytes(transmission, sizeof(transmission), true, true);
}

// changes behaviour to 0 in RAM -> ON in display panel and 1 in RAM -> OFF in display panel
bool ssd1306_invert_display(void) {
    // control byte first: Co=0, D/C=0 → command stream with no more control bytes
    byte transmission[2] = {SSD1306_CONTROL_BYTE(0, 0), 0xA7};
    return ssd1306_write_bytes(transmission, sizeof(transmission), true, true);
}

// changes behaviour to the normal behaviour: 0 in RAM -> OFF in display and 1 in RAM -> ON on display
bool ssd1306_normal_display(void) {
    // control byte first: Co=0, D/C=0 → command stream with no more control bytes
    byte transmission[2] = {SSD1306_CONTROL_BYTE(0, 0), 0xA6};
    return ssd1306_write_bytes(transmission, sizeof(transmission), true, true);
}

// could be useful if you want to waste time
bool ssd1306_nop(void) {
    byte transmission[2] = {SSD1306_CONTROL_BYTE(0, 0), 0xE3};
    return ssd1306_write_bytes(transmission, sizeof(transmission), true, true);
}

// turns entire display ON
bool ssd1306_on(void) {
    byte transmission[2] = {SSD1306_CONTROL_BYTE(0, 0), 0xAE};
    return ssd1306_write_bytes(transmission, sizeof(transmission), true, true);
}

// turns entire display OFF
bool ssd1306_off(void) {
    byte transmission[2] = {SSD1306_CONTROL_BYTE(0, 0), 0xAF};
    return ssd1306_write_bytes(transmission, sizeof(transmission), true, true);
}

// displays the contents of GDDRAM
bool ssd1306_display(void) {
    // A4 is the command for entire display ON with RAM contents showing
    byte transmission[2] = {SSD1306_CONTROL_BYTE(0, 0), 0xA4};
    return ssd1306_write_bytes(transmission, sizeof(transmission), true, true);
}

bool ssd1306_set_addressing_mode(const ADDRESSING_MODE mode) {
    byte lower_bits = 0x0;
    // the mode we want will determine what the last two bits of the command are
    switch(mode) {
        case PAGE:
        // this is considered a RESET since it's the default
            lower_bits = (byte)0b10;
        break;
        case HORIZONTAL:
            lower_bits = (byte)0b00;
        break;
        case VERTICAL:
            lower_bits = (byte)0b01;
        break;
        default:
            // datasheet says this is INVALID, so should never be used
            lower_bits = (byte)0b11;
        break;
    }
    // command is 0x20 OR'd with the lower two bits
    byte transmission[2] = {SSD1306_CONTROL_BYTE(0, 0), (0x20 | lower_bits)};
    return ssd1306_write_bytes(transmission, sizeof(transmission), true, true);
}

/*  FONT DEFINED FROM ASCII 32 -> 127 */
static const uint8_t font8x8[94][8] = {
    /*  ASCII PRINTABLE CHARACTERS */
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //  032 -> 0x20 ( ) (space)
    {0x00, 0x00, 0x00, 0x5F, 0x5F, 0x00, 0x00, 0x00}, //  033 -> 0x21 (!)
    {0x00, 0x07, 0x07, 0x00, 0x07, 0x07, 0x00, 0x00}, //  034 -> 0x22 (")
    {0x14, 0x7F, 0x7F, 0x14, 0x7F, 0x7F, 0x14, 0x00}, //  035 -> 0x23 (#)
    {0x00, 0x24, 0x2A, 0x7F, 0x7F, 0x2A, 0x12, 0x00}, //  036 -> 0x24 ($)
    {0x46, 0x66, 0x30, 0x18, 0x0C, 0x66, 0x62, 0x00}, //  037 -> 0x25 (%)
    {0x30, 0x7A, 0x4F, 0x5D, 0x37, 0x7A, 0x48, 0x00}, //  038 -> 0x26 (&)
    {0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x00}, //  039 -> 0x27 (')
    {0x00, 0x00, 0x1C, 0x3E, 0x63, 0x41, 0x00, 0x00}, //  040 -> 0x28 (()
    {0x00, 0x00, 0x41, 0x63, 0x3E, 0x1C, 0x00, 0x00}, //  041 -> 0x29 ())
    {0x08, 0x2A, 0x3E, 0x1C, 0x1C, 0x3E, 0x2A, 0x08}, //  042 -> 0x2a (*)
    {0x00, 0x08, 0x08, 0x3E, 0x3E, 0x08, 0x08, 0x00}, //  043 -> 0x2b (+)
    {0x00, 0x00, 0x80, 0xE0, 0x60, 0x00, 0x00, 0x00}, //  044 -> 0x2c (,)
    {0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00}, //  045 -> 0x2d (-)
    {0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00}, //  046 -> 0x2e (.)
    {0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00}, //  047 -> 0x2f (/)
    {0x3E, 0x7F, 0x51, 0x49, 0x45, 0x7F, 0x3E, 0x00}, //  048 -> 0x30 (0)
    {0x00, 0x40, 0x42, 0x7F, 0x7F, 0x40, 0x40, 0x00}, //  049 -> 0x31 (1)
    {0x00, 0x72, 0x7B, 0x49, 0x49, 0x6F, 0x66, 0x00}, //  050 -> 0x32 (2)
    {0x00, 0x22, 0x63, 0x49, 0x49, 0x7F, 0x36, 0x00}, //  051 -> 0x33 (3)
    {0x18, 0x1C, 0x16, 0x53, 0x7F, 0x7F, 0x50, 0x00}, //  052 -> 0x34 (4)
    {0x00, 0x2F, 0x6F, 0x49, 0x49, 0x79, 0x33, 0x00}, //  053 -> 0x35 (5)
    {0x00, 0x3E, 0x7F, 0x49, 0x49, 0x7B, 0x32, 0x00}, //  054 -> 0x36 (6)
    {0x00, 0x03, 0x03, 0x71, 0x79, 0x0F, 0x07, 0x00}, //  055 -> 0x37 (7)
    {0x00, 0x36, 0x7F, 0x49, 0x49, 0x7F, 0x36, 0x00}, //  056 -> 0x38 (8)
    {0x00, 0x26, 0x6F, 0x49, 0x49, 0x7F, 0x3E, 0x00}, //  057 -> 0x39 (9)
    {0x00, 0x00, 0x00, 0x6C, 0x6C, 0x00, 0x00, 0x00}, //  058 -> 0x3a (:)
    {0x00, 0x00, 0x80, 0xEC, 0x6C, 0x00, 0x00, 0x00}, //  059 -> 0x3b (;)
    {0x00, 0x08, 0x1C, 0x36, 0x63, 0x41, 0x00, 0x00}, //  060 -> 0x3c (<)
    {0x00, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x00}, //  061 -> 0x3d (=)
    {0x00, 0x41, 0x63, 0x36, 0x1C, 0x08, 0x00, 0x00}, //  062 -> 0x3e (>)
    {0x00, 0x06, 0x07, 0x51, 0x59, 0x0F, 0x06, 0x00}, //  063 -> 0x3f (?)
    {0x3E, 0x7F, 0x41, 0x5D, 0x5D, 0x5F, 0x1E, 0x00}, //  064 -> 0x40 (@)
    {0x00, 0x7C, 0x7E, 0x13, 0x13, 0x7E, 0x7C, 0x00}, //  065 -> 0x41 (A)
    {0x41, 0x7F, 0x7F, 0x49, 0x49, 0x7F, 0x36, 0x00}, //  066 -> 0x42 (B)
    {0x1C, 0x3E, 0x63, 0x41, 0x41, 0x63, 0x22, 0x00}, //  067 -> 0x43 (C)
    {0x41, 0x7F, 0x7F, 0x41, 0x63, 0x3E, 0x1C, 0x00}, //  068 -> 0x44 (D)
    {0x41, 0x7F, 0x7F, 0x49, 0x5D, 0x41, 0x63, 0x00}, //  069 -> 0x45 (E)
    {0x41, 0x7F, 0x7F, 0x49, 0x1D, 0x01, 0x03, 0x00}, //  070 -> 0x46 (F)
    {0x1C, 0x3E, 0x63, 0x41, 0x51, 0x73, 0x72, 0x00}, //  071 -> 0x47 (G)
    {0x00, 0x7F, 0x7F, 0x08, 0x08, 0x7F, 0x7F, 0x00}, //  072 -> 0x48 (H)
    {0x00, 0x41, 0x41, 0x7F, 0x7F, 0x41, 0x41, 0x00}, //  073 -> 0x49 (I)
    {0x30, 0x70, 0x40, 0x41, 0x7F, 0x3F, 0x01, 0x00}, //  074 -> 0x4a (J)
    {0x41, 0x7F, 0x7F, 0x08, 0x1C, 0x77, 0x63, 0x00}, //  075 -> 0x4b (K)
    {0x41, 0x7F, 0x7F, 0x41, 0x40, 0x60, 0x70, 0x00}, //  076 -> 0x4c (L)
    {0x7F, 0x7F, 0x0E, 0x1C, 0x0E, 0x7F, 0x7F, 0x00}, //  077 -> 0x4d (M)
    {0x7F, 0x7F, 0x06, 0x0C, 0x18, 0x7F, 0x7F, 0x00}, //  078 -> 0x4e (N)
    {0x1C, 0x3E, 0x63, 0x41, 0x63, 0x3E, 0x1C, 0x00}, //  079 -> 0x4f (O)
    {0x41, 0x7F, 0x7F, 0x49, 0x09, 0x0F, 0x06, 0x00}, //  080 -> 0x50 (P)
    {0x3C, 0x7E, 0x43, 0x51, 0x33, 0x6E, 0x5C, 0x00}, //  081 -> 0x51 (Q)
    {0x41, 0x7F, 0x7F, 0x09, 0x19, 0x7F, 0x66, 0x00}, //  082 -> 0x52 (R)
    {0x00, 0x26, 0x6F, 0x49, 0x49, 0x7B, 0x32, 0x00}, //  083 -> 0x53 (S)
    {0x00, 0x03, 0x41, 0x7F, 0x7F, 0x41, 0x03, 0x00}, //  084 -> 0x54 (T)
    {0x00, 0x3F, 0x7F, 0x40, 0x40, 0x7F, 0x3F, 0x00}, //  085 -> 0x55 (U)
    {0x00, 0x1F, 0x3F, 0x60, 0x60, 0x3F, 0x1F, 0x00}, //  086 -> 0x56 (V)
    {0x7F, 0x7F, 0x30, 0x18, 0x30, 0x7F, 0x7F, 0x00}, //  087 -> 0x57 (W)
    {0x61, 0x73, 0x1E, 0x0C, 0x1E, 0x73, 0x61, 0x00}, //  088 -> 0x58 (X)
    {0x00, 0x07, 0x4F, 0x78, 0x78, 0x4F, 0x07, 0x00}, //  089 -> 0x59 (Y)
    {0x47, 0x63, 0x71, 0x59, 0x4D, 0x67, 0x73, 0x00}, //  090 -> 0x5a (Z)
    {0x00, 0x00, 0x7F, 0x7F, 0x41, 0x41, 0x00, 0x00}, //  091 -> 0x5b ([)
    {0x01, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00}, //  092 -> 0x5c (\)
    {0x00, 0x00, 0x41, 0x41, 0x7F, 0x7F, 0x00, 0x00}, //  093 -> 0x5d (])
    {0x08, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x08, 0x00}, //  094 -> 0x5e (^)
    {0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80}, //  095 -> 0x5f (_)
    {0x00, 0x00, 0x01, 0x03, 0x06, 0x04, 0x00, 0x00}, //  096 -> 0x60 (`)
    {0x20, 0x74, 0x54, 0x54, 0x3C, 0x78, 0x40, 0x00}, //  097 -> 0x61 (a)
    {0x41, 0x7F, 0x3F, 0x44, 0x44, 0x7C, 0x38, 0x00}, //  098 -> 0x62 (b)
    {0x00, 0x38, 0x7C, 0x44, 0x44, 0x6C, 0x28, 0x00}, //  099 -> 0x63 (c)
    {0x38, 0x7C, 0x44, 0x45, 0x3F, 0x7F, 0x40, 0x00}, //  100 -> 0x64 (d)
    {0x00, 0x38, 0x7C, 0x54, 0x54, 0x5C, 0x18, 0x00}, //  101 -> 0x65 (e)
    {0x00, 0x48, 0x7E, 0x7F, 0x49, 0x03, 0x02, 0x00}, //  102 -> 0x66 (f)
    {0x00, 0x98, 0xBC, 0xA4, 0xA4, 0xFC, 0x7C, 0x00}, //  103 -> 0x67 (g)
    {0x41, 0x7F, 0x7F, 0x08, 0x04, 0x7C, 0x78, 0x00}, //  104 -> 0x68 (h)
    {0x00, 0x00, 0x44, 0x7D, 0x7D, 0x40, 0x00, 0x00}, //  105 -> 0x69 (i)
    {0x00, 0x60, 0xE0, 0x80, 0x84, 0xFD, 0x7D, 0x00}, //  106 -> 0x6a (j)
    {0x41, 0x7F, 0x7F, 0x10, 0x38, 0x6C, 0x44, 0x00}, //  107 -> 0x6b (k)
    {0x00, 0x00, 0x41, 0x7F, 0x7F, 0x40, 0x00, 0x00}, //  108 -> 0x6c (l)
    {0x78, 0x7C, 0x0C, 0x38, 0x0C, 0x7C, 0x78, 0x00}, //  109 -> 0x6d (m)
    {0x04, 0x7C, 0x78, 0x04, 0x04, 0x7C, 0x78, 0x00}, //  110 -> 0x6e (n)
    {0x00, 0x38, 0x7C, 0x44, 0x44, 0x7C, 0x38, 0x00}, //  111 -> 0x6f (o)
    {0x84, 0xFC, 0xF8, 0xA4, 0x24, 0x3C, 0x18, 0x00}, //  112 -> 0x70 (p)
    {0x18, 0x3C, 0x24, 0xA4, 0xF8, 0xFC, 0x84, 0x00}, //  113 -> 0x71 (q)
    {0x44, 0x7C, 0x78, 0x4C, 0x04, 0x0C, 0x08, 0x00}, //  114 -> 0x72 (r)
    {0x00, 0x48, 0x5C, 0x54, 0x54, 0x74, 0x20, 0x00}, //  115 -> 0x73 (s)
    {0x00, 0x04, 0x3F, 0x7F, 0x44, 0x64, 0x20, 0x00}, //  116 -> 0x74 (t)
    {0x00, 0x3C, 0x7C, 0x40, 0x40, 0x7C, 0x7C, 0x00}, //  117 -> 0x75 (u)
    {0x00, 0x1C, 0x3C, 0x60, 0x60, 0x3C, 0x1C, 0x00}, //  118 -> 0x76 (v)
    {0x3C, 0x7C, 0x60, 0x38, 0x60, 0x7C, 0x3C, 0x00}, //  119 -> 0x77 (w)
    {0x44, 0x6C, 0x38, 0x10, 0x38, 0x6C, 0x44, 0x00}, //  120 -> 0x78 (x)
    {0x00, 0x9C, 0xBC, 0xA0, 0xA0, 0xFC, 0x7C, 0x00}, //  121 -> 0x79 (y)
    {0x00, 0x4C, 0x64, 0x74, 0x5C, 0x4C, 0x64, 0x00}, //  122 -> 0x7a (z)
    {0x00, 0x08, 0x08, 0x3E, 0x77, 0x41, 0x41, 0x00}, //  123 -> 0x7b ({)
    {0x00, 0x00, 0x00, 0x7F, 0x7F, 0x00, 0x00, 0x00}, //  124 -> 0x7c (|)
    {0x00, 0x41, 0x41, 0x77, 0x3E, 0x08, 0x08, 0x00}, //  125 -> 0x7d (})
    {0x10, 0x18, 0x08, 0x18, 0x10, 0x18, 0x08, 0x00}, //  126 -> 0x7e (~)
};

uint8_t* get_bitmap_from_ascii(uint8_t character) {
    if (character < 32 || character > 126) {
        // if invalid, don't set any pixels (will look like nothing or a space)
        return (uint8_t*) {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    }
    return font8x8[character - 32];
}

#endif // ssd1306_I2C.h